# NinjaDark Chrome Extension Analysis
## Overview
*NinjaDark* is a lightweight Chrome extension designed to apply a dark mode to the NinjaRMM web application interface. It does so by inverting the colors of the page and then selectively correcting certain elements to preserve their intended appearance. The extension’s codebase is minimal, consisting of a manifest file, a content script (JavaScript), and a content stylesheet (CSS). There are no background scripts or additional permissions declared beyond the specific site it targets. According to the manifest, the extension is restricted to running only on the NinjaRMM web app domain (`https://app.ninjarmm.com/*`) , meaning it will not execute on other websites. The content scripts are injected at page document_start, ensuring the dark mode styles apply as early as possible in the page load process. 

At a high level, NinjaDark works by injecting a CSS filter that inverts all colors on the page, effectively turning light backgrounds dark and vice versa. A companion JavaScript (content script) then runs to adjust images, videos, and elements with specific color backgrounds so that they appear normal (not color-inverted). This approach achieves a dark theme without altering the website’s underlying data or functionality – it’s purely a visual transformation. The extension does not include any user interface of its own (no toolbar button or options page) and operates silently whenever the user visits the NinjaRMM site.
## Security and Privacy Assessment
From a security and privacy perspective, the NinjaDark extension appears *benign and focused solely on visual modifications*. The code was reviewed for common vulnerabilities and privacy risks (such as DOM manipulation issues, data exfiltration, external network calls, insecure coding practices, etc.), and no red flags were found. Below is a summary of key points regarding security and privacy:
- Limited Scope (Domain Restriction): The extension’s manifest explicitly limits execution to the NinjaRMM app domain. It does not run on arbitrary websites, which greatly reduces its scope of impact. It cannot access or inject code into other sites, guarding the user’s data on unrelated web pages.
- No Network Communication: The content script does not perform any network requests (no AJAX/XHR, fetch, WebSocket, or calls to external APIs). We found no code that sends data to any server or URL. In fact, the extension does not even declare permissions for internet access beyond the target domain. This means it has no built-in capability to leak or transmit your browsing data externally. There are also no analytics or tracking pixels embedded. All operations are done locally in the browser on the page’s DOM.
- No Data Collection or Storage: The extension does not collect personal data or store information beyond the current session’s needs. It uses a JavaScript WeakMap in memory to remember some elements’ color status, but this is not persistent storage and does not survive beyond the page’s lifetime. There is no use of cookies, localStorage, or Chrome storage. Because there’s no background script or cloud component, nothing is saved or sent out – preserving user privacy.
- Safe DOM Manipulation: The only DOM manipulations performed are the addition of CSS filters (to invert colors) and setting inline style on certain elements. These operations are deterministic and do not involve injecting any HTML from external sources or executing any unknown scripts. For example, the CSS content script simply applies a global CSS rule to invert colors, and the JS uses document.querySelectorAll and window.getComputedStyle to examine elements’ styles and then applies inline style adjustments. There is no use of innerHTML/outerHTML, no dangerous string building, and no eval or similar dynamic code execution. This means the extension is not introducing new XSS vectors or code injection risks into the page. It’s only modifying style properties in a controlled way.
- Isolated Context: The content script runs in Chrome’s isolated extension context. It does interact with the page’s DOM, but it does not expose any new functions or variables to the page that untrusted page scripts could exploit. All its variables (like the originalColors WeakMap) live in the extension’s scope, not the page’s JavaScript context. This isolation is a security feature of Chrome extensions, ensuring that even though the script touches the DOM, the page cannot directly call extension functions or tamper with its internal data.
- Event Handling: The script uses event listeners (DOMContentLoaded) and a MutationObserver to respond to page load and DOM changes. These are standard, safe practices. There is no evidence of insecure event handling (e.g., no global event overrides or memory leaks from unremoved listeners). The observer is appropriately scoped to monitor additions to the DOM and does not expose any sensitive data; it purely reacts to insertions by applying styles. This reactive behavior does not open any obvious security holes – it doesn't, for instance, execute any data based on page content beyond reading style properties.
- No Elevated Permissions: The manifest does not request any high-risk permissions (such as tabs, webRequest, activeTab, or file system access). It only uses a content script on a specific site, which is one of the least privileged ways to make an extension. There’s also no permission for arbitrary host access – just the NinjaRMM domain. This means the extension cannot intercept network traffic, cannot read clipboard or downloads, etc. Essentially, it runs with minimal privileges needed for the style injection.
- Code Clarity and Integrity: The source code is small and straightforward. It’s not obfuscated or minified, which suggests there is no hidden malicious logic. We can clearly see it doing what is expected for a dark mode (inverting colors and fixing certain elements), and nothing more. This transparency is a good sign for security since obscured code often raises flags.
In summary, no security vulnerabilities or privacy issues were identified in NinjaDark. The extension does not leak data or communicate with third parties, and its DOM manipulations are confined to style changes (unlikely to break site security). The primary impact of this extension is visual; it should not affect the underlying site functionality or user data. Users reviewing this extension for security can be confident that its behavior is limited to theming the interface, without spying on or interfering with sensitive information.
##Code Behavior and File Breakdown
Let's break down the extension’s components and explain what each file does, how it works, and what happens at runtime:
### `manifest.json`
This JSON file defines the extension’s metadata and configuration. Important fields in manifest.json include:
- Manifest Version: It uses "manifest_version": 3, indicating it follows Chrome Extension Manifest V3 format (the latest format with enhanced security, e.g., no persistent background scripts by default).
- Name, Version, Description: The extension is named "NinjaDark" with version "1.0.0". The description notes it is a "Dark mode for NinjaRMM with inverted colors". These are just identifiers and do not affect security or functionality beyond how the extension is listed to the user.
- Icons: The manifest specifies icons in two sizes (48px and 128px) for the extension’s icon assets. These are image files (icons/icon-48.png and icons/icon-128.png) included in the extension package. They are used by Chrome (e.g., in the extensions page or toolbar if pinned) but have no runtime effect on the content script. (They are static resources and not part of any code execution.)
- Content Scripts: This is the core of the extension’s behavior. The manifest declares a content script entry:
  - `"matches": ["https://app.ninjarmm.com/*"]` – This means the scripts will inject only on pages whose URL matches the NinjaRMM web app domain. If you navigate to that domain, the extension becomes active; on any other domain, it stays inert.
  - `"css": ["content.css"]` – The file content.css will be injected into the page. This CSS runs at the specified run timing (see run_at below) and contains the rules to invert the page colors.
  - `"js": ["content.js"]` – The file content.js is the JavaScript content script to inject. This will execute in the context of the page (but isolated from the page’s own scripts) and handle dynamic adjustments for the dark mode.
  - `"run_at": "document_start"` – This setting ensures that both the CSS and JS content scripts are injected at the earliest stage of page loading (before the page’s own scripts run, and before the DOM is fully built). In practice, the CSS is applied almost immediately, so the page starts in dark mode from the get-go, and the JS will execute as soon as possible (it will likely wait for DOM content to be ready before it can do its full work, as we’ll see). Using document_start helps avoid a white flash before the dark styling kicks in and allows the script to capture original colors before the page fully renders.
Notably, there are no other sections in the manifest: no "permissions" (aside from the implicit host permission for the match), no background service worker, no options page, and no content accessible resources beyond the ones mentioned. This simplicity means the extension’s functionality is narrowly focused on the content script tasks.
### content.css
This is a short CSS file injected into the target pages. Its job is to invert the site’s colors to achieve a dark mode effect. The content of content.css is as follows:
```
html {
  filter: invert(1) hue-rotate(180deg) !important;
}
```
This CSS rule targets the root HTML element of the page. It applies a CSS filter: `invert(1) hue-rotate(180deg)` (with `!important` priority to override any site styles). Here’s what this means:
- filter: invert(1) inverts the brightness of all elements on the page. Essentially, it turns light colors dark and dark colors light. For example, a white background becomes black, black text becomes white, etc.
- hue-rotate(180deg) shifts all colors by 180 degrees on the color wheel. This is often used in combination with invert to adjust the resulting colors. Pure inversion can sometimes yield strange color casts (for instance, a blue might invert to a bright yellow); rotating the hue by 180° helps make the inverted colors look more natural or closer to an expected “dark mode” palette.
- Combining these filters, effectively every pixel on the page is color-inverted and hue-adjusted. The rule is applied to the html element so it affects the entire page content.
The comment in the file `/* Invert everything by default */` succinctly describes its purpose. By injecting this CSS at document start, the extension ensures that as the page loads, it is immediately rendered in inverted colors. However, this blanket approach will also invert things that we might not want inverted (images, videos, and certain UI elements that are already dark or meant to be specific colors). That’s where the content script comes in – to selectively undo the inversion on those parts. Aside from this one rule, content.css contains no other selectors or styles. It doesn’t reference external resources or do anything dynamic – it’s a static CSS injection.
### content.js
This JavaScript file is the heart of the extension’s logic. It executes on the NinjaRMM page to fine-tune the dark mode effect after the CSS inversion is applied. Below is a breakdown of its functionality and how it operates at runtime:
- WeakMap for Original Colors: At the very top, the script creates a WeakMap called originalColors to store information about elements’ original background colors. A WeakMap is used so that it doesn’t prevent garbage collection of DOM elements (avoiding memory leaks). This map will hold entries for elements that originally had significant color in their background, so the script knows to handle them differently after inversion.
- Color Significance Check (hasSignificantColor): The script defines a helper function hasSignificantColor(color, threshold = 30). This function takes a CSS color string (e.g. "rgb(255, 200, 50)") and determines whether the color is “significant” or essentially a strong, non-neutral color. It does this by:
  - Extracting the numeric R, G, B components from the string.
  - Computing the maximum difference between the R, G, and B values.
  - If the max difference is greater than the threshold (30 by default), it returns true (meaning the color has enough contrast between channels to likely be a vivid color). If the values are all very close to each other (difference <= 30), the color is near grayscale (a shade of grey or subtle color), and it returns false.
In simpler terms, this function identifies brightly or distinctly colored backgrounds versus those that are white, gray, or nearly monochromatic. The rationale is that in a dark mode, inverting a gray or light background (to dark) is usually fine (desired), but inverting a bright, colorful background can distort intended meaning (for example, a red alert banner inverted might turn cyan, which could be confusing). So the extension treats “significant” colors differently from neutral ones.
- Capturing Original Colors (captureOriginalColors): This function is called at initial load to record which elements have colorful backgrounds before the inversion is applied. Here’s how it works:
  1. It temporarily disables the global CSS filter by setting document.documentElement.style.filter = 'none'. This removes the inversion effect momentarily, so the page’s true original colors can be inspected via the DOM.
  2. It then selects all elements on the page (document.querySelectorAll('*')) and iterates through them. For each element, it gets the computed style and extracts the backgroundColor.
  3. If an element’s background color is non-transparent and considered significant (using the hasSignificantColor check), the script stores that element in the originalColors WeakMap with a flag (e.g. { hasColorfulBg: true }). Essentially, it marks “this element had a notably colored background originally.”
  4. After scanning all elements, it re-enables the invert filter by clearing the inline style on the root (document.documentElement.style.filter = '', which allows the CSS from content.css to take effect again). Now the page is back to inverted colors, but the script has recorded which elements were originally colorful.
This capture step ensures the script knows which parts of the page might need to be corrected after the inversion. It’s executed once on page load (after DOM content is ready). There may be a brief visual effect: because the CSS started inverting from the beginning, disabling it and re-enabling it could cause a quick flash of original colors and back. However, this is likely very fast. The trade-off is necessary to accurately detect original colors.
- Processing Elements (processElement): After capturing original color info, the script defines how each element should be adjusted under the dark mode:
  - For any element that is an image or media (the code checks if element.tagName is IMG, VIDEO, PICTURE, CANVAS, or IFRAME) – these are elements where a full-color inversion would look wrong – the script applies a CSS filter of invert(1) hue-rotate(180deg) to that element inline. This is done with element.style.setProperty(..., 'important') to override any site CSS. Applying the same invert+hue-rotate filter to the element itself effectively double-inverts it relative to the already inverted page. The result is that the image/video/canvas appears in its normal, original colors. For example, if a company logo was originally blue on white, the global invert would make it orange on black; by double-inverting just the image, it returns to blue (on the now-dark background). The script uses a return after this operation, meaning if an element is a media type, it does nothing further for it (skips the next step).
  - For any other element, the script checks if that element was marked in the originalColors map as having a colorful background. If so, it similarly applies filter: invert(1) hue-rotate(180deg) to that element. This again double-inverts that specific element (and its content), canceling out the global inversion for it. In effect, this restores the element’s original background color (and any child elements’ colors) to how they were. The reason is to preserve the intended UI color cues – for instance, if a table row was highlighted in bright yellow, or a button was originally bright green, the extension will keep it that way even in dark mode, rather than turning those colors into something else. If the element was not in the map (meaning its original background was not notably colorful, likely just white or gray), the script leaves it as-is, so it remains inverted (which typically turns light backgrounds dark – the goal of dark mode).
  This processElement function encapsulates the core logic of “undoing” the inversion selectively. It doesn’t change any text content or attributes; it purely sets a CSS filter style on elements to visually adjust them.
- Processing All Elements (processAllElements): This is a utility that simply goes through every element on the page (document.querySelectorAll('*')) and runs the above processElement on each. Right after the initial capture, the script calls this to apply the necessary fixes to all images and marked colorful-background elements in one go.
- Initialization (init function): The init() function ties together the above steps – it calls captureOriginalColors() first, then processAllElements(). This ensures that by the time the page is fully loaded and the user starts interacting, all visible elements have been adjusted for dark mode correctly. The script triggers init() once the DOM is ready:
  - If the content script runs while the document is still loading (which it will, due to run_at: document_start), it attaches a listener for the DOMContentLoaded event to call init when the DOM is complete.
  - If by some chance the script runs after the DOM is already loaded (e.g., if the script was injected late), it calls init immediately. In practice, with document_start, the former case is what happens: the script waits until the page’s HTML is loaded to begin the capture and processing.
- Dynamic Updates with MutationObserver: After the initial pass, the script sets up a MutationObserver to handle any new elements that get added to the page dynamically. Many web apps (especially something like NinjaRMM’s interface) dynamically update the DOM (for example, loading new data, opening dialogs, etc.), and those new elements might otherwise appear with inverted colors if not handled.
  - The observer watches the entire document body (subtree: true) for any added nodes (childList: true). It does not watch attribute modifications or removals (only additions of nodes).
  - When a new node is added, the observer callback runs. For each added node, if it’s an element node (nodeType === 1):
    - The script obtains its computed backgroundColor. If the new element has a non-transparent background and it’s a significant color by the earlier criteria, the element is recorded in the originalColors map just like during initial capture.
    - Then the script calls processElement(node) on the new element to apply any needed filter (double-inversion) immediately.
    - Additionally, it goes through all descendants of that new element (in case a whole subtree was added) using node.querySelectorAll('*'), and for each child element, does the same check: record it if it has a colorful background, and call processElement(child). This ensures that if an entire section of UI is introduced (say a pop-up modal with many elements), every image or colored background inside it gets the appropriate treatment.
  - This observer keeps running for the lifetime of the page, so any time content is injected (user navigation within the app, new data tables, etc.), the dark mode adjustments are applied on-the-fly. There is a slight overhead to this – computing styles for new nodes – but it is confined to changes and should be manageable. Importantly, this process again does not involve any external communication or data leaks; it’s purely reacting to DOM changes internally.
  - The observer is started as soon as the document body exists. The code checks if document.body is already present and if so, begins observing immediately; if not (on the rare chance the script ran truly at document_start before the <body> is created), it waits for DOMContentLoaded to start the observer. This is a minor detail to ensure no added nodes are missed.
- No Other Behavior: The content script does not define any other functions or listeners beyond what’s described. It does not respond to user input events, does not modify form data, and does not attempt to interact with the network or Chrome extension APIs (like no chrome.runtime.sendMessage or storage calls). Once running, its sole role is to maintain the correct visual state (dark mode) on the page.

**Runtime Summary:** When you load the NinjaRMM web app with NinjaDark enabled, the sequence is:
1. The page begins loading; NinjaDark’s CSS is injected immediately, turning the screen dark from the start.
2. As the DOM finishes loading, NinjaDark’s JS runs init(): it momentarily lifts the dark filter to scan original colors, then reapplies the dark filter and fixes all images and colorful elements to appear correctly.
3. The result is that the UI is now mostly dark (whites have become black/gray, etc.), but logos, photos, and originally colored indicators retain their proper colors (preventing strange color inversions).
4. As you use the app, any new content that appears will quickly be processed by the MutationObserver – you might not even notice this happening, aside from the fact that new images or panels already look right (no odd inverted colors) when they render.
5. The extension does not otherwise impact the app’s behavior; buttons, data, and functionality remain unchanged aside from the color scheme.
## Other Files (Icons)
Although not part of the executable code, it’s worth noting the extension includes icon files (icon-48.png and icon-128.png) referenced in the manifest. These are standard icon assets and do not affect runtime behavior or security. They are simply used by the browser to display the extension’s icon in the extensions menu or toolbar. They do not interact with the content script or web page.
## Conclusion
NinjaDark is a straightforward Chrome extension that injects CSS and JavaScript into the NinjaRMM web app to provide a dark mode theme. The code is focused on visual transformation and is written in a clear, modular way (separating the style inversion and the corrective logic). Our security review indicates that the extension does not introduce security vulnerabilities: it doesn’t execute arbitrary code, doesn’t perform unsafe DOM manipulations, and cannot exfiltrate data. Its content script runs with limited privileges and strictly targets one domain, which is a good practice for minimizing risk. 

In summary, the extension’s files work together to invert the page colors and correct specific elements:
- The manifest restricts where and how the extension runs, with no extra bloat or permissions.
- The CSS inverts the color scheme globally.
- The JavaScript then dynamically ensures images and important colors look right under the new scheme, both on initial load and during any dynamic content changes.

This design is both effective for its purpose and conservative in terms of security and privacy. Users and reviewers can understand exactly what it’s doing, and there are no hidden functionalities beyond the dark mode implementation described. All data stays on the user’s machine, and the extension simply delivers a nicer visual experience for the NinjaRMM application without compromising security.

